trigger: none

pool:
  vmImage: 'windows-2022' # Use a Windows agent with Visual Studio and .NET Framework SDKs

steps:
- task: NuGetToolInstaller@1
  displayName: 'Install NuGet'

- task: PowerShell@2
  displayName: 'Build and Run All Basic Data Source Projects'
  inputs:
    targetType: 'inline'
    script: |
      # Define the specific directory to search for projects
      $searchRoot = "Embedded .NET Engine Samples\Basic\Data Source Usage"
      $searchPath = Join-Path -Path "$(System.DefaultWorkingDirectory)" -ChildPath $searchRoot

      # Define the list of project folder names to exclude
      $excludedFolders = @("CustomCallbacks", "CustomFunctions", "GenerateAnyDocumentCommandLine", "RunReportDB2")

      # --- Find MSBuild.exe before starting ---
      # Use the vswhere utility to locate the latest Visual Studio installation path
      $vsPath = & "C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe" -latest -property installationPath
      $msbuildPath = Join-Path $vsPath "MSBuild\Current\Bin\MSBuild.exe"

      if (-not (Test-Path $msbuildPath)) {
          Write-Error "Could not find MSBuild.exe at the expected path: $msbuildPath"
          exit 1
      }
      Write-Host "Found MSBuild at: $msbuildPath"
      # --- End MSBuild discovery ---

      # Check if the specified directory exists
      if (-not (Test-Path -Path $searchPath -PathType Container)) {
          Write-Error "The specified search directory does not exist: $searchPath"
          exit 1
      }

      Write-Host "Searching for projects in: $searchPath"

      # Find all .csproj files recursively from the specified directory
      $csprojFiles = Get-ChildItem -Path $searchPath -Recurse -Filter *.csproj

      if (-not $csprojFiles) {
          Write-Host "No .csproj files found in the specified directory. Pipeline will succeed."
          exit 0
      }

      # Initialize lists to track success and failure
      $successProjects = @()
      $failedProjects = @()

      Write-Host "Found $($csprojFiles.Count) project files. Filtering for console applications..."
      $consoleProjects = @()

      # Loop through all found projects to identify which ones are console apps (<OutputType>Exe</OutputType>)
      foreach ($file in $csprojFiles) {
          try {
              [xml]$projContent = Get-Content -Path $file.FullName
              if ($projContent.Project.PropertyGroup.OutputType -eq 'Exe') {
                  # Check if the project's parent folder name is in the exclusion list
                  if ($excludedFolders -contains $file.Directory.Name) {
                      Write-Host "  [-] Skipping excluded project: $($file.Name) in folder $($file.Directory.Name)"
                  } else {
                      Write-Host "  [+] Identified Console App: $($file.Name)"
                      $consoleProjects += $file
                  }
              }
          } catch {
              Write-Warning "Could not parse $($file.FullName). It might be an older format or invalid. Skipping."
          }
      }

      if (-not $consoleProjects) {
          Write-Host "No console application projects were found (after exclusions). Pipeline will succeed."
          exit 0
      }

      Write-Host "-----------------------------------------------------------------"
      Write-Host "Starting build and run for $($consoleProjects.Count) identified console project(s)."
      Write-Host "-----------------------------------------------------------------"

      # Process each identified console project
      foreach ($project in $consoleProjects) {
          $projectName = $project.Name
          $projectPath = $project.FullName
          $hasFailed = $false

          Write-Host "##[group]Processing Project: $projectName"

          # Step 1: Restore NuGet packages using nuget.exe
          Write-Host "Restoring NuGet packages for: $projectPath"
          nuget restore $projectPath
          if ($LASTEXITCODE -ne 0) {
              Write-Error "NuGet restore FAILED for project: $projectName"
              $hasFailed = $true
          } else {
              Write-Host "NuGet restore SUCCEEDED."

              # Step 2: Build the project using the full path to MSBuild
              Write-Host "Building project with MSBuild: $projectPath"
              & $msbuildPath $projectPath /nologo /nr:false /p:Configuration=Debug
              if ($LASTEXITCODE -ne 0) {
                  Write-Error "Build FAILED for project: $projectName"
                  $hasFailed = $true
              } else {
                  Write-Host "Build SUCCEEDED."

                  # Step 3: Run the compiled .exe
                  # Construct the path to the output executable
                  $exePath = Join-Path -Path $project.DirectoryName -ChildPath "bin\Debug\$($project.BaseName).exe"
                  if (-not (Test-Path $exePath)) {
                      Write-Error "Could not find compiled executable at: $exePath"
                      $hasFailed = $true
                  } else {
                      $exeDir = Split-Path -Path $exePath -Parent
                      Write-Host "Setting working directory to executable's location: $exeDir"
                      Push-Location -Path $exeDir
                      
                      Write-Host "Executing: .\$($project.BaseName).exe"
                      # Execute by name, explicitly referencing the current directory with '.\'
                      & ".\$($project.BaseName).exe"
                      if ($LASTEXITCODE -ne 0) {
                          Write-Error "Execution FAILED for project: $projectName. The application returned a non-zero exit code: $LASTEXITCODE"
                          $hasFailed = $true
                      } else {
                          Write-Host "Execution SUCCEEDED (Exit Code: 0)."
                      }
                      
                      # Return to the original directory
                      Pop-Location
                  }
              }
          }

          # Add the project to the appropriate success or failure list
          if ($hasFailed) {
              $failedProjects += $projectName
          } else {
              $successProjects += $projectName
          }

          Write-Host "##[endgroup]"
      }

      # --- Final Summary ---
      Write-Host "-----------------------------------------------------------------"
      Write-Host "Final Summary"
      Write-Host "-----------------------------------------------------------------"
      Write-Host "✅ Successful projects: $($successProjects.Count)"
      $successProjects | ForEach-Object { Write-Host "  - $_" }

      Write-Host "❌ Failed projects: $($failedProjects.Count)"
      $failedProjects | ForEach-Object { Write-Host "  - $_" }
      Write-Host "-----------------------------------------------------------------"

      # Fail the pipeline if any project failed
      if ($failedProjects.Count -gt 0) {
          Write-Error "$($failedProjects.Count) project(s) failed. See logs for details."
          exit 1
      }

      Write-Host "✅ All console projects were built and ran successfully!"
