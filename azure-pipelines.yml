# # ASP.NET Core (.NET Framework)
# # Build and test ASP.NET Core projects targeting the full .NET Framework.
# # Add steps that publish symbols, save build artifacts, and more:
# # https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core

# trigger:
# - main

# pool:
#   vmImage: 'windows-latest'

# variables:
#   solution: '**/*.sln'
#   buildPlatform: 'Any CPU'
#   buildConfiguration: 'Release'

# steps:
# - task: NuGetToolInstaller@1

# - task: NuGetCommand@2
#   inputs:
#     restoreSolution: '$(solution)'

# - task: VSBuild@1
#   inputs:
#     solution: '$(solution)'
#     msbuildArgs: '/p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:DesktopBuildPackageLocation="$(build.artifactStagingDirectory)\WebApp.zip" /p:DeployIisAppPath="Default Web Site"'
#     platform: '$(buildPlatform)'
#     configuration: '$(buildConfiguration)'

# - task: VSTest@2
#   inputs:
#     platform: '$(buildPlatform)'
#     configuration: '$(buildConfiguration)'
# azure-pipelines.yml
#
# This pipeline finds all .NET console projects in a specific directory,
# builds them, runs them, and verifies that each one executes successfully.
# A non-zero exit code from any project will fail the pipeline.

# azure-pipelines.yml
#
# This pipeline finds all .NET console projects in a specific directory,
# builds them, and runs them. It will test all projects, even if some fail.
# At the end, it provides a summary and fails the pipeline if any project failed.

# By setting the trigger to 'none', this pipeline will only run when manually triggered.
# azure-pipelines.yml
#
# This pipeline finds all .NET console projects in a specific directory,
# restores their NuGet packages, builds them, and runs them. It will test all
# projects, even if some fail. At the end, it provides a summary and fails
# the pipeline if any project failed.
trigger: none

pool:
  vmImage: 'windows-2022' # Use a Windows agent with Visual Studio and .NET Framework SDKs

steps:
- task: NuGetToolInstaller@1
  displayName: 'Install NuGet'

- task: PowerShell@2
  displayName: 'Build and Run All Console Projects'
  inputs:
    targetType: 'inline'
    script: |
      # Define the specific directory to search for projects
      $searchRoot = "Embedded .NET Engine Samples\Basic\Data Source Usage"
      $searchPath = Join-Path -Path "$(System.DefaultWorkingDirectory)" -ChildPath $searchRoot

      # Define the list of project folder names to exclude
      $excludedFolders = @("CustomCallbacks", "CustomFunctions", "GenerateAnyDocumentCommandLine", "RunReportDB2")

      # --- Find MSBuild.exe before starting ---
      # Use the vswhere utility to locate the latest Visual Studio installation path
      $vsPath = & "C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe" -latest -property installationPath
      $msbuildPath = Join-Path $vsPath "MSBuild\Current\Bin\MSBuild.exe"

      if (-not (Test-Path $msbuildPath)) {
          Write-Error "Could not find MSBuild.exe at the expected path: $msbuildPath"
          exit 1
      }
      Write-Host "Found MSBuild at: $msbuildPath"

      # Check if the specified directory exists
      if (-not (Test-Path -Path $searchPath -PathType Container)) {
          Write-Error "The specified search directory does not exist: $searchPath"
          exit 1
      }

      Write-Host "Searching for projects in: $searchPath"

      # Find all .csproj files recursively from the specified directory
      $csprojFiles = Get-ChildItem -Path $searchPath -Recurse -Filter *.csproj

      if (-not $csprojFiles) {
          Write-Host "No .csproj files found in the specified directory. Pipeline will succeed."
          exit 0
      }

      # Initialize lists to track success and failure
      $successProjects = @()
      $failedProjects = @()

      Write-Host "Found $($csprojFiles.Count) project files. Filtering for console applications..."
      $consoleProjects = @()

      # Loop through all found projects to identify which ones are console apps (<OutputType>Exe</OutputType>)
      foreach ($file in $csprojFiles) {
          try {
              [xml]$projContent = Get-Content -Path $file.FullName
              if ($projContent.Project.PropertyGroup.OutputType -eq 'Exe') {
                  # Check if the project's parent folder name is in the exclusion list
                  if ($excludedFolders -contains $file.Directory.Name) {
                      Write-Host "  [-] Skipping excluded project: $($file.Name) in folder $($file.Directory.Name)"
                  } else {
                      Write-Host "  [+] Identified Console App: $($file.Name)"
                      $consoleProjects += $file
                  }
              }
          } catch {
              Write-Warning "Could not parse $($file.FullName). It might be an older format or invalid. Skipping."
          }
      }

      if (-not $consoleProjects) {
          Write-Host "No console application projects were found (after exclusions). Pipeline will succeed."
          exit 0
      }

      Write-Host "-----------------------------------------------------------------"
      Write-Host "Starting build and run for $($consoleProjects.Count) identified console project(s)."
      Write-Host "-----------------------------------------------------------------"

      # Process each identified console project
      foreach ($project in $consoleProjects) {
          $projectName = $project.Name
          $projectPath = $project.FullName
          $hasFailed = $false

          Write-Host "##[group]Processing Project: $projectName"

          # Step 1: Restore NuGet packages using nuget.exe
          Write-Host "Restoring NuGet packages for: $projectPath"
          nuget restore $projectPath
          if ($LASTEXITCODE -ne 0) {
              Write-Error "NuGet restore FAILED for project: $projectName"
              $hasFailed = $true
          } else {
              Write-Host "NuGet restore SUCCEEDED."

              # Step 2: Build the project using MSBuild
              Write-Host "Building project with MSBuild: $projectPath"
              msbuild $projectPath /nologo /nr:false /p:Configuration=Debug
              if ($LASTEXITCODE -ne 0) {
                  Write-Error "Build FAILED for project: $projectName"
                  $hasFailed = $true
              } else {
                  Write-Host "Build SUCCEEDED."

                  # Step 3: Run the compiled .exe
                  # Construct the path to the output executable
                  $exePath = Join-Path -Path $project.DirectoryName -ChildPath "bin\Debug\$($project.BaseName).exe"
                  if (-not (Test-Path $exePath)) {
                      Write-Error "Could not find compiled executable at: $exePath"
                      $hasFailed = $true
                  } else {
                      Write-Host "Executing: $exePath"
                      & $exePath
                      if ($LASTEXITCODE -ne 0) {
                          Write-Error "Execution FAILED for project: $projectName. The application returned a non-zero exit code: $LASTEXITCODE"
                          $hasFailed = $true
                      } else {
                          Write-Host "Execution SUCCEEDED (Exit Code: 0)."
                      }
                  }
              }
          }

          # Add the project to the appropriate success or failure list
          if ($hasFailed) {
              $failedProjects += $projectName
          } else {
              $successProjects += $projectName
          }

          Write-Host "##[endgroup]"
      }

      # --- Final Summary ---
      Write-Host "-----------------------------------------------------------------"
      Write-Host "Final Summary"
      Write-Host "-----------------------------------------------------------------"
      Write-Host "✅ Successful projects: $($successProjects.Count)"
      $successProjects | ForEach-Object { Write-Host "  - $_" }

      Write-Host "❌ Failed projects: $($failedProjects.Count)"
      $failedProjects | ForEach-Object { Write-Host "  - $_" }
      Write-Host "-----------------------------------------------------------------"

      # Fail the pipeline if any project failed
      if ($failedProjects.Count -gt 0) {
          Write-Error "$($failedProjects.Count) project(s) failed. See logs for details."
          exit 1
      }

      Write-Host "✅ All console projects were built and ran successfully!"